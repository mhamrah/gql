package generator

import (
	"bytes"
	"errors"
	"fmt"

	"github.com/mhamrah/gql/ast"
)

const generatedHeader = "// @generated\n// generated by gql\n\n"

func Generate(schema *ast.Schema, packageName string) (map[string]bytes.Buffer, error) {
	files := make(map[string]bytes.Buffer)

	if len(schema.OperationTypeDefinitions) == 0 {
		query, ok := schema.TypeDefinitions["Query"]
		if !ok {
			return nil, errors.New("Parsed schema has no operation type definitions nor a \"Query\" type")
		}
		delete(schema.TypeDefinitions, "Query")
		q, ok := query.(ast.ObjectDefinition)
		if !ok {
			return nil, errors.New("Query definition is not an ObjectDefinition")
		}

		op, err := writeOperation(q, packageName)
		if err != nil {
			return nil, err
		}

		files["service.go"] = op
	}

	if len(schema.TypeDefinitions) > 0 {
		types, err := writeTypes(schema.TypeDefinitions, packageName)
		if err != nil {
			return nil, err
		}
		files["types.go"] = types
	}

	return files, nil
}

func writeOperation(od ast.ObjectDefinition, packageName string) (bytes.Buffer, error) {
	var op bytes.Buffer
	writeHeader(&op, packageName)
	writeImports(&op)
	if err := od.GenerateOperation(&op); err != nil {
		return op, err
	}
	return op, nil
}

func writeHeader(b *bytes.Buffer, packageName string) {
	b.WriteString(generatedHeader)
	b.WriteString(fmt.Sprintf("package %v\n\n", packageName))
}

func writeImports(b *bytes.Buffer) {
	b.WriteString("import (\n")
	b.WriteString("\"fmt\"\n")
	b.WriteString("\"context\"\n")
	b.WriteString("\"github.com/mhamrah/gql\"\n")
	b.WriteString("\"github.com/mhamrah/gql/ast\"\n")
	b.WriteString(")\n\n")
}

func writeTypes(types map[string]ast.TypeDefinition, packageName string) (bytes.Buffer, error) {
	var b bytes.Buffer

	writeHeader(&b, packageName)
	for _, t := range types {
		t.Generate(&b)
	}

	return b, nil
}
